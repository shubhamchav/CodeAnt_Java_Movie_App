name: Movie Service CI/CD

on:
  push:
    branches: [main,develop]


permissions:
  id-token: write
  contents: read


jobs:

  build:
    runs-on: group-2-runner-tag
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Run Unit Tests
        run: mvn test

      - name: Security Scan (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          trivy-args: '--skip-version-check'

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'zulu'
          
      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Sonarqube analyze
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -Dsonar.projectKey=movieservice-world -Dsonar.projectName='movieservice-world' -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml

      - name: Build movie-service
        run: mvn clean package -DskipTests

      - name: Upload Build Folder
        uses: actions/upload-artifact@v4
        with:
          name: build-folder
          path: target/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      - name: Docker Image Scan (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}
          format: 'table'
          exit-code: '0'
          trivy-args: '--skip-version-check'

  deploy:
    needs: build
    runs-on: group-2-runner-tag
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Setup kubectl
      - uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.1'

      # Configure AWS credentials for kubectl & EKS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Update kubeconfig for EKS
      - name: Configure kubectl
        run: aws eks --region ${{ secrets.AWS_REGION }} update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }}

      # Install NGINX Ingress Controller (if not installed)
      - name: Install NGINX Ingress Controller
        run: |
          if ! kubectl get ns ingress-nginx >/dev/null 2>&1; then
            echo "Installing NGINX Ingress Controller..."
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
            echo "Waiting for Ingress controller LoadBalancer..."
            kubectl wait --namespace ingress-nginx \
              --for=condition=available --timeout=300s deployment/ingress-nginx-controller
          else
            echo "Ingress Controller already installed."
          fi
      # Replace image in deployment.yaml
      - name: Update deployment image
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          sed -i "s|REPLACE_WITH_TAG|$IMAGE_TAG|" manifest/deployment.yaml
      # Deploy Deployment & Service
      - name: Deploy Deployment & Service
        run: |
          kubectl apply -f manifest/deployment.yaml
          kubectl apply -f manifest/service.yaml
      # Deploy Ingress
      - name: Deploy Ingress
        run: kubectl apply -f manifest/ingress.yaml

      # Optional: Get Ingress hostname
      # - name: Get Ingress hostname
      #   run: |
      #     echo "Ingress hostnames for both services:"
      #     kubectl get ingress movieapp-ingress-movies
      




